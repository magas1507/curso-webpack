***Tu primer build con Webpack
*Creamos una carpeta como le quieras llamar
(Bueno no! si eres de Windows te dejo este articulo cortito de los nombres de carpetas PROHIBIDOS )
La creamos desde la terminal con mkdir y luego entramos a ella con cd

mkdir curso-webpack
cd curso-webpack

*una vez que entres a la carpeta inicializamos nuestro repositorio con git

git init

*El paso que sigue es inicializar nuestro proyecto con npm y si no sabes de npm aqui esta el curso del profesor

npm init -y

*o si les da error ‚ÄúInvalid Name‚Äù usen para personalizar la configuraci√≥n

npm init

*y para abrir el proyecto como flash es poner en la terminal y les abre el editor ( si usas VS CODE)

code .

*La carpeta SRC es el source de todo el proyecto ( index.js , im√°genes, utils, assets, helpers, database, etc).

*** Instalaci√≥n de Webpack**
si no quieres escribir ese comando tambi√©n puedes usar este
la i de install

*npm i webpack webpack-cli -D
o si usas yarn usa

yarn add webpack webpack-cli -D

*Y luego ejecutamos webpack

npx lo que hace es ejecutar paquetes directamente de npm, este viene instalado de npm

*npx webpack

Al hacer esto webpack creo una carpeta llamada dist, esto lo hace por defecto webpack sin preguntarnos.

Modo de desarrollo
Por defecto webpack al compilar nuestro proyecto setea el modo ‚Äúproduction‚Äù impl√≠citamente pero podemos definirle el modo expl√≠citamente corriendo:

npx webpack --mode production
npx webpack --mode development
La diferencia radica que el modo development deja el c√≥digo mas legible para los desarrolladores pero con comentarios, el modo production deja el c√≥digo comprimido y mas limpio para usarse.

***Instalaci√≥n de Webpack y construcci√≥n del proyecto

1)Clonar el proyecto
  git clone https://github.com/gndx/js-portfolio.git

2)Instalar webpack
  con npm
  npm install webpack webpack-cli -D 
  
  con Yarn
  yarn add webpack webpack-cli -D 

  ***üíõ Babel Loader para JavaScript
<h4>Apuntes</h4>
Babel te permite hacer que tu c√≥digo JavaScript sea compatible con todos los navegadores
Debes agregar a tu proyecto las siguientes dependencias
NPM

npm install -D babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime
Yarn

yarn add -D babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime
babel-loader nos permite usar babel con webpack
@babel/core es babel en general
@babel/preset-env trae y te permite usar las ultimas caracter√≠sticas de JavaScript
@babel/plugin-transform-runtime te permite trabajar con todo el tema de asincronismo como ser async y await


Debes crear el archivo de configuraci√≥n de babel el cual tiene como nombre .babelrc
{
  "presets": [
    "@babel/preset-env"
  ],
  "plugins": [
    "@babel/plugin-transform-runtime"
  ]
}
Para comenzar a utilizar webpack debemos agregar la siguiente configuraci√≥n en webpack.config.js
{
...,
module: {
    rules: [
      {
        // Test declara que extensi√≥n de archivos aplicara el loader
        test: /\.js$/,
        // Use es un arreglo u objeto donde dices que loader aplicaras
        use: {
          loader: "babel-loader"
        },
        // Exclude permite omitir archivos o carpetas especificas
        exclude: /node_modules/
      }
    ]
  }
}
RESUMEN: Babel te ayuda a transpilar el c√≥digo JavaScript, a un resultado el cual todos los navegadores lo puedan entender y ejecutar. Trae ‚Äúextensiones‚Äù o plugins las cuales nos permiten tener caracter√≠sticas m√°s all√° del JavaScript com√∫n

***üìò Loaders para CSS y preprocesadores de CSS
<h4>Ideas/conceptos claves</h4>
Un preprocesador CSS es un programa que te permite generar CSS a partir de la syntax √∫nica del preprocesador. Existen varios preprocesadores CSS de los cuales escoger, sin embargo, la mayor√≠a de preprocesadores CSS a√±adir√°n algunas caracter√≠sticas que no existen en CSS puro, como variable, mixins, selectores anidados, entre otros. Estas caracter√≠sticas hacen la estructura de CSS m√°s legible y f√°cil de mantener.

post procesadores son herramientas que procesan el CSS y lo transforman en una nueva hoja de CSS que le permiten optimizar y automatizar los estilos para los navegadores actuales.

<h4>Apuntes</h4>
Para dar soporte a CSS en webpack debes instalar los siguientes paquetes
Con npm

npm i mini-css-extract-plugin css-loader -D
Con yarn

yarn add mini-css-extract-plugin css-loader -D
css-loader ‚áí Loader para reconocer CSS
mini-css-extract-plugin ‚áí Extrae el CSS en archivos
Para comenzar debemos agregar las configuraciones de webpack
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
	...,
	module: {
    rules: [
      {
        test: /\.(css|styl)$/i,
        use: [
          MiniCssExtractPlugin.loader,
          "css-loader",
        ]
      }
    ]
  },
  plugins: [
		...
    new MiniCssExtractPlugin(),
  ]
}
Si deseamos posteriormente podemos agregar herramientas poderosas de CSS como ser:
pre procesadores
Sass
Less
Stylus
post procesadores
Post CSS
RESUMEN: Puedes dar soporte a CSS en webpack mediante loaders y plugins, adem√°s que puedes dar superpoderes al mismo con las nuevas herramientas conocidas como pre procesadores y post procesadores

*** Copia de archivos con Webpack
<h4>Apuntes</h4>
Si tienes la necesidad de mover un archivo o directorio a tu proyecto final podemos usar un plugin llamado ‚Äúcopy-webpack-plugin‚Äù
Para instalarlo debemos ejecutar el comando
Para npm

npm i copy-webpack-plugin -D
Para yarn

yarn add copy-webpack-plugin -D
Para poder comenzar a usarlo debemos agregar estas configuraciones a webpack.config.js
...
const CopyPlugin = require('copy-webpack-plugin');

module.exports = {
	...
  plugins: [
    new CopyPlugin({
      patterns: [
        {
          from: path.resolve(__dirname, "src", "assets/images"),
          to: "assets/images"
        }
      ]
    }),
  ]
}
Es importante las propiedades from y to
From ‚áí que recurso (archivo o directorio) deseamos copiar al directorio final
To ‚áí en que ruta dentro de la carpeta final terminara los recursos

***Loaders de fuentes
En las options:

options: {
        limit: 10000, // O LE PASAMOS UN BOOLEANOS TRUE O FALSE
        // Habilita o deshabilita la transformaci√≥n de archivos en base64.
       mimetype: 'aplication/font-woff',
       // Especifica el tipo MIME con el que se alinear√° el archivo. 
       // Los MIME Types (Multipurpose Internet Mail Extensions)
       // son la manera standard de mandar contenido a trav√©s de la red.
       name: "[name].[ext]",
       // EL NOMBRE INICIAL DEL ARCHIVO + SU EXTENSI√ìN
       // PUEDES AGREGARLE [name]hola.[ext] y el output del archivo seria 
       // ubuntu-regularhola.woff
       outputPath: './assets/fonts/', 
       // EL DIRECTORIO DE SALIDA (SIN COMPLICACIONES)
       publicPath: './assets/fonts/',
       // EL DIRECTORIO PUBLICO (SIN COMPLICACIONES)
      esModule: false 
	   // AVISAR EXPLICITAMENTE SI ES UN MODULO
}
Para las imagenes

assetModuleFilename: 'assets/images/[hash][ext]'
Esta instrucci√≥n hace que webpack le agregue un hash ( un hash es una serie de caracteres aleatorios) y su extencion por medio de esas variables en el string
Asi quedo el Webpack Config

const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const CopyPlugin = require('copy-webpack-plugin')

module.exports = {
    // mode: 'production', // LE INDICO EL MODO EXPLICITAMENTE
    entry: './src/index.js', // el punto de entrada de mi aplicaci√≥n
    output: { // Esta es la salida de mi bundle
        path: path.resolve(__dirname, 'dist'),
        // resolve lo que hace es darnos la ruta absoluta de el S.O hasta nuestro archivo
        // para no tener conflictos entre Linux, Windows, etc
        filename: 'main.js', 
        // EL NOMBRE DEL ARCHIVO FINAL,
        assetModuleFilename: 'assets/images/[hash][ext][query]'
    },
    resolve: {
        extensions: ['.js'] // LOS ARCHIVOS QUE WEBPACK VA A LEER
    },
    module: {
        // REGLAS PARA TRABAJAR CON WEBPACK
        rules : [
            {
                test: /\.m?js$/, // LEE LOS ARCHIVOS CON EXTENSION .JS,
                exclude: /node_modules/, // IGNORA LOS MODULOS DE LA CARPETA
                use: {
                    loader: 'babel-loader'
                }
            },
            {
                test: /\.css|.styl$/i,
                use: [ MiniCssExtractPlugin.loader, 'css-loader' , 'stylus-loader' ]
            },
            {
                test: /\.png/, // REGLA PARA ACEPTAR IMAGENES .PNG
                type: 'asset/resource'
            },
            {
                test: /\.(woff|woff2)$/, // REGLA PARA ARCHIVOS WOFF | WOFF2
                use: {
                    loader: 'url-loader', // NOMBRE DEL LOADER
                    options: {
                        limit: false, // O LE PASAMOS UN NUMERO
                        // Habilita o deshabilita la transformaci√≥n de archivos en base64.
                        mimetype: 'aplication/font-woff',
                        // Especifica el tipo MIME con el que se alinear√° el archivo. 
                        // Los MIME Types (Multipurpose Internet Mail Extensions)
                        // son la manera standard de mandar contenido a trav√©s de la red.
                        name: "[name].[ext]",
                        // EL NOMBRE INICIAL DEL PROYECTO + SU EXTENSI√ìN
                        // PUEDES AGREGARLE [name]hola.[ext] y el output del archivo seria 
                        // ubuntu-regularhola.woff
                        outputPath: './assets/fonts/', 
                        // EL DIRECTORIO DE SALIDA (SIN COMPLICACIONES)
                        publicPath: './assets/fonts/',
                        // EL DIRECTORIO PUBLICO (SIN COMPLICACIONES)
                        esModule: false
                    }
                }
            }
        ]
    },
    // SECCION DE PLUGINS
    plugins: [
        new HtmlWebpackPlugin({ // CONFIGURACI√ìN DEL PLUGIN
            inject: true, // INYECTA EL BUNDLE AL TEMPLATE HTML
            template: './public/index.html', // LA RUTA AL TEMPLATE HTML
            filename: './index.html'// NOMBRE FINAL DEL ARCHIVO
        }),
        new MiniCssExtractPlugin(), // INSTANCIAMOS EL PLUGIN
        new CopyPlugin({ // CONFIGURACI√ìN DEL COPY PLUGIN
            patterns: [
                {
                    from: path.resolve(__dirname , "src" , 'assets/images'), // CARPETA A MOVER AL DIST
                    to: "assets/images"// RUTA FINAL DEL DIST
                }
            ]
        })
    ]
}

***Te ayudo a entender algunas cosas. üòÉ
Rules
Webpack es muy personalizable, desde el module, la rule, los plugins por lo que se podr√°n observar muchas configuraciones.
Recuerda que url-loader ya est√° integrada como m√≥dulo en Webpack 5 por lo que no es necesario instalarla, a menos que desees configurar ciertos par√°metros como lo son limit para especificar el tama√±o m√°ximo de tus archivos en bytes donde si el archivo es igual o m√°s grande utiliza el file-loader para que procese su rendimiento, esModule es para permitir que file-loader genere modulos JS que usan la sintaxis ES. Documentatci√≥n de url-loader.

url-loader, incorporado en Webpack 5 permite configurar algunos par√°metros gen√©ricos.

Rule.mimetype - nos permite determinar el tipo de archivo que ser√° enlazado o cargado.
module.exports = {
  // ...
  module: {
    rules: [
      {
        mimetype: 'application/json',
        type: 'json',
      },
    ],
  },
};
Notar√°s que ser√° utilizado para JS en la carga de m√≥dulos que tendr√°n, o pueden tener, contendio est√°tico.

Rule.generator.filename- Donde espeficamos el nombre de la salida para con la regla donde tu mencionas ‚ÄúEL NOMBRE DEL ARCHIVO FINAL‚Äù el cual no esta del todo mal, pero complementaria que m√°s que un nombre, es una regla que acompa√±ar√° los archivos mapeados con asset/resource
Al final, te presento el webpack.config.js que estoy maquetando:

...
        output: {
            path: resolve(__dirname, 'dist'),
            filename: 'bondle.js',
            assetModuleFilename: 'assets/images/[hash][ext][query]',
        },
...
        module: {
            rules: [
                {
                    test: /\.(png|svg|jpg|jpeg|gif)$/i,
                    type: 'asset/resource',
                },
                {
                    test: /\.(woff|woff2|eot|ttf|otf)$/i,
                    type: 'asset/resource',
                    generator: {
                        filename: 'assets/fonts/[hash][ext]',
                    },
                },
...
Configuraciones m√°s, configuraciones menos, te adjunt√© los enlaces para que complementes tu documentaci√≥n y puedas elaborar m√°s tipos de archvios de configuraci√≥n de webpack

***¬øPor qu√© es importante usar Hashes en nuestros archivos?
Los recursos que se guardan en memoria cache suceden cuando el navegador entra a un sitio por primera vez detecta los recursos y los guarda. Por ello la siguiente vez sera mucho m√°s r√°pido porque estar√°n en memoria
La desventaja esta cuando sacamos una nueva versi√≥n, porque tendr√°n un mismo nombre evitando que se descargue los nuevos cambios, por lo tanto, el usuario no recibir√° los nuevos cambios
Para que no haya conflictos con la cache una vez que tengamos nuestro proyecto en producci√≥n es importante darles un hash para cada nueva versi√≥n

Probando un poco m√°s dentro del proyecto, para activar terser por defecto de webpack solo debemos usar el siguiente c√≥digo

module.exports = {
... 
optimization: {
    minimize: true
  }
}
Es decir que no podemos usar la propiedad minimizer: []. Pero si dese√°ramos personalizar la optimizaci√≥n y agregar plugins como ser css-minimizer-webpack-plugin ahi toca instalar y usar terser-webpack-plugin dentro de optimizations, otro caso de este tipo ser√≠a si desearas personalizar el plugin de terser.

OPTIMIZATION WITH WEBPACK üòÑ

RECURSOS OP

<h3>¬øPor qu√© es importante usar Hashes en nuestros archivos?</h3>
Los recursos que se guardan en memoria cache suceden cuando el navegador entra a un sitio por primera vez detecta los recursos y los guarda. Por ello la siguiente vez sera mucho m√°s r√°pido porque estar√°n en memoria
La desventaja esta cuando sacamos una nueva versi√≥n, porque tendr√°n un mismo nombre evitando que se descargue los nuevos cambios, por lo tanto, el usuario no recibir√° los nuevos cambios
Para que no haya conflictos con la cache una vez que tengamos nuestro proyecto en producci√≥n es importante darles un hash para cada nueva versi√≥n
Segun la documentaci√≥n oficial de webpack nos comunica que actualmente terser-webpack-plugin viene incluido desde webpack 5 üòÑ

Fuente:

TerserWebpackPlugin

Probando un poco m√°s dentro del proyecto, para activar terser por defecto de webpack solo debemos usar el siguiente c√≥digo

module.exports = {
...
optimization: {
    minimize:true
  }
}

Es decir que no podemos usar la propiedad minimizer: []. Pero si dese√°ramos personalizar la optimizaci√≥n y agregar plugins como ser css-minimizer-webpack-plugin ahi toca instalar y usar terser-webpack-plugin dentro de optimizations, otro caso de este tipo ser√≠a si desearas personalizar el plugin de terser

Una de las cosas mas importantes por la cual utilizamos webpack es la optimizaci√≥n de nuestro proyecto, en comprimir nuestro css, nuestro javascript y optimizar nuestras imagenes, entre otras caracteristicas.

Vamos a instalar unas dependencias que nos ayudaran con esto

npm install css-minimizer-webpack-plugin terser-webpack-plugin -D
Ahora vamos a a√±adir nuestra configuraci√≥n en nuestro archivo de webpack
//Importamos los plugins que acabamos de instalar
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const TerserPlugin = requiere('terser-webpack-plugin');
Luego vamos a a√±adir esto a nuestro archivo como una nueva configuraci√≥n llamada optimization
optimization:{
    minimize: true,
    minimizer: [
      //Instanciamos las dependencias que estamos importando
      new CssMinimizerPlugin(),
      new TerserPlugin(),
    ]
  }
Otra de las optimizaciones que podemos realizar para poder verificar las versiones que estamos trabajando tiene que ver mucho directamente con los hash

Asi que vamos a identificar cada bild de nuestro proyecto con un hash

a√±adimos los hash en output
output:{
    path: path.resolve(__dirname, 'dist'),
    //cambios este elemento y le pondremos tanto el name para que lo identifique
      //como la parte del contenthash para que nos muestre eso
    filename: '[name].[contenthash].js',
    //para insertar el cambio y mover las fuentes a otra carpte lo hacemos aqui
    assetModuleFilename: 'assets/image/[hash][ext][query]'
  },
lo a√±adimos en nuestras fuentes
{

        test: /\.(woff|woff2)$/,
        use: {
          loader: 'url-loader',
          options:{

            limit:10000,
            mimetype:"application/font-woff",
            name: "[name].[contenthash].[ext]",
            outputPath: "./assets/fonts/",
            publicPath: "./assets/fonts/",
            esModule: false,
          }
        }

      }
Lo a√±adimos en la instancia de la dependencia que compila nuestro css
//Le anadimos una configuracion al plugin que nos permite compilar en css
    new MiniCssExtracPlugin({

      filename: 'assets/[name].[contenthash].css'

    }),
Terminamos la configuracion y ahora compilamos webpack y podremos ver los archivos optimizados en dist/assets

*** Webpack Alias
<h4>Apuntes</h4>
Alias ‚áí nos permiten otorgar nombres paths espec√≠ficos evitando los paths largos
Para crear un alias debes agregar la siguiente configuraci√≥n a webpack

No olvides comentar que alias forma parte del objeto resolve el cual nos permite configurar la forma en que webpack resolver√° los m√≥dulos incorporados.
En nuestro camino, tenemos dos:

resolve.alias - para crear atajos que optimizan el tiempo de b√∫squeda e incorporaci√≥n de m√≥dulos (commonJS o ES6)
resolve.extensions - para darle prioridad en resoluci√≥n para con las extensiones donde si hay archivos nombrados igualmente, pero con diferentes extensiones, webpack resolver√° conforme est√°n listados.

En esta clase vamos a aprender a como utilizar alias para los paths que estamos utilizando

Para crear un alias debes agregar la siguiente configuraci√≥n a webpack

resolve:{

    extensions:['.js'],
    //Agregamos una key alias a nuestro objeto resolve
      //para ponerles nombres mas pequenos a las extensiones
        //de nuestros archivos
    alias:{
      '@utils': path.resolve(__dirname, 'src/utils/'),
      '@templates': path.resolve(__dirname, 'src/templates/'),
      '@styles': path.resolve(__dirname, 'src/styles/'),
      '@images': path.resolve(__dirname, 'src/assets/images/'),

    }
  }
Estos alias los vamos a poder utilizar dentro de nuestro proyecto para que cuando webpack lo prepare va a identificar que esta es la ruta a la que tenemos que entrar

Luego agregamos estos alias en nuestras rutas en nuestro archivo de js
import Template from '@templates/Template.js';
import '@styles/main.css';

(async function App() {
  const main = null || document.getElementById('main');
  main.innerHTML = await Template();
})();
Lo agregamos en nuestro archivo que genera nuestro template
import getData from '@utils/getData.js';
//importamos la configuracion de las imagenes

import github from '@images/github.png';
import twitter from '@images/twitter.png';
import instagram from '@images/instagram.png';

***Variables de entorno
<h4>Apuntes</h4>
Es importante considerar las variables de entorno va a ser un espacio seguro donde podemos guardar datos sensibles
Por ejemplo, subir llaves al repositorio no es buena idea cuando tienes un proyecto open source
Para instalar debemos correr el comando
NPM

npm install -D dotenv-webpack
YARN

yarn add -D dotenv-webpack
Posteriormente debemos crear un archivo .env donde estar√°n la clave para acceder a la misma y el valor que contendr√°n

# Ejemplo
API=https://randomuser.me/api/
Es buena idea tener un archivo de ejemplo donde, el mismo si se pueda subir al repositorio como muestra de que campos van a ir
Una vez creado el archivo .env debemos agregar la siguiente configuraci√≥n en webpack.config.js

...
const Dotenv = require('dotenv-webpack');
module.exports = {
	...
	plugins: [
		new Dotenv()
  ],
}
dotenv-webpack ‚áí Leera el archivo .env por defecto y lo agregar a nuestro proyecto
Para usarlas debes hacer lo siguiente
const nombre = process.env.NOMBRE_VARIABLE;
Toda la configuraci√≥n se podr√° acceder desde process.env

***Webpack en modo desarrollo
Creamos un nuevo archivo:
webpack.config.dev.js
Copiamos todo lo de webpack.config.js a el archivo que acabamos de crear.
Borramos o comentamos el siguiente c√≥digo, ya que no necesitamos optimizar para el modo de desarrollo (Queremos ver cuando funcionan las cosas).
    optimization: {
        minimize: true,
        minimizer: [
            new CssMinimizerPlugin(),
            new TerserPlugin()
        ]
    }
Tambi√©n borramos o comentamos por la misma raz√≥n:

const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin')
Seguido del atributo output a√±adimos:
output: {
},
mode: 'development',
En package.json:
"dev": "webpack --config webpack.config.dev.js" 
y ejecutamos npm run dev

*** Webpack en modo producci√≥n
<h4>Apuntes</h4>
Actualmente tenemos el problema de tener varios archivos repetidos los cuales se fueron acumulando por compilaciones anteriores
Para ello puedes limpiar la carpeta cada vez que hacemos un build, usando clean-webpack-plugin
Cabe recalcar que esta caracter√≠stica es mucho m√°s util para la configuraci√≥n de producci√≥n
Para instalarlo debes correr el siguiente comando:
NPM

npm install -D clean-webpack-plugin
YARN

yarn add -D clean-webpack-plugin
Para agregarlo a nuestra configuraci√≥n de webpack agregamos los siguientes cambios a webpack.config.js
...
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
module.exports = {
	...
	plugins: [
		...
		new CleanWebpackPlugin()
	]
}